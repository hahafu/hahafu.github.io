<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[struts2_04]]></title>
    <url>%2F2019%2F04%2F24%2Fstruts2_04%2F</url>
    <content type="text"><![CDATA[struts2学习_04一、结果页面配置1、全局结果页面（1）result标签配置action方法返回值到不同的路劲里面（2）创建两个Action执行默认的方法execute方法，让两个方法都返回success,返回success之后，配置到同一个页面 如果多个action，方法里面返回值相同的，到页面也是相同的这个时候可以使用全局结果页面配置 12345678&lt;package name="Stationery" extends="struts-default" namespace="/"&gt; &lt;action name="book" class="cn.com.action.BookAction"&gt; &lt;result name="success"&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="pen" class="cn.com.action.PenAction"&gt; &lt;result name="success"&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 在package标签里配置全局结果页面 1234&lt;!-- 全局结果页面配置 --&gt; &lt;global-results&gt; &lt;result name="success"&gt;/hello.jsp&lt;/result&gt; &lt;/global-results&gt; 2、局部结果页面配置了全局结果页面，也配置了局部结果页面，最终以局部结果页面配置为准1234567891011121314&lt;package name="Stationery" extends="struts-default" namespace="/"&gt; &lt;!-- 全局结果页面配置 --&gt; &lt;global-results&gt; &lt;result name="success"&gt;/hello.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;!-- 局部结果页面配置 --&gt; &lt;action name="book" class="cn.com.action.BookAction"&gt; &lt;!-- 以局部结果页面配置为准 --&gt; &lt;result name="success"&gt;/book.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="pen" class="cn.com.action.PenAction"&gt; &lt;result name="success"&gt;/pen.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 3、Result标签type属性（1）result标签除了有name属性，还有type属性 type属性：如何到路径里面（转发和重定向）（2）type属性值 dispatcher：默认值，请求转发操作， dispatcher：重定向操作，无法共享请求范围内的数据 chain：将action的带着原来的状态请求转发到新的action，一般不建议使用，缓存问题 redirect-action：重定向到另一个Action，参数与chain用法相同，允许将原Action中的属性指定新名称带入新Action中 dispatcher、redirect，这两个值一般针对到页面中配置 chain、redirect-action配置到其他action里 二、在action获取表单提交数据1 之前web阶段，提交表单到servlet里面，在servlet里面使用request对象里面的方法获取，getParameter，getParameterMap 2 提交表单到action，但是action没有request对象，不能直接使用request对象 3 action获取表单提交数据主要三种方式（1）使用ActionContext类（2）使用ServletActionContext类（3）使用接口注入方式 1、使用ActionContext类获取（1）使用方法 Map&lt;String,Object&gt;getParameter() 返回一个含有HttpServletRequest参数信 static ActionContext getContext() 获取当前线程的ActionContext对像 方法不是静态的，需要创建ActionContext类对象 ActionContext对象不是new出来的（2）具体实现 创建表单，提交表单到action 在action的方法中使用ActionContext获取数据123456789101112//使用ActionContext类获取表单数据 //1、获取actionContext对象 ActionContext context = ActionContext.getContext(); //2、调用方法得到表单数据 //key是表单输入项里的name值，value是输入的值 Map&lt;String, Object&gt; map = context.getParameters(); Set&lt;String&gt; keys=map.keySet(); for (String key : keys) &#123; //用数组形式是因为输入项可能有复选框的情况 Object[] obj = (Object[]) map.get(key); System.out.println(Arrays.toString(obj)); &#125; 2、使用servletActionContext类获取 static HttpServletRequest() 获取Web应用的 HttpServletRequest对象 static HttpServletResponse() 获取Web应用的 HttpServletResponse对象 static ServletContext.getServletContext 获取Web应用的 ServletContext对象 static PageContext.getPageContext 获取Web应用的 PageContext对象 （1）使用方法 调用类的静态方法，得到request对象 action中代码实现 1234567891011public String execute() throws Exception &#123; //使用ServletActionContext获取request对象 HttpServletRequest request = ServletActionContext.getRequest(); //调用request里的方法得到结果 String userName = request.getParameter("userName"); String password = request.getParameter("password"); String address = request.getParameter("address"); return NONE;&#125; 3、使用接口注入方式获取（1）让action类实现ServletRequestAware接口12345678910111213public class HelloAction extends ActionSupport implements ServletRequestAware&#123; private HttpServletRequest request; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request = request; &#125; @Override public String execute() throws Exception &#123; request.getParameter(""); return super.execute(); &#125; &#125; 4、在action操作域对象（1）request、session、servletContext域对象（2）使用ServletActionContext类操作123456789//request域 HttpServletRequest request = ServletActionContext.getRequest(); request.setAttribute("requestName", "requestValue"); //session域 HttpSession session = request.getSession(); session.setAttribute("sessionName", "sessionValue"); //servletContext域 ServletContext context = ServletActionContext.getServletContext(); context.setAttribute("contextName", "contextValue"); 三、struts2提供获取表单数据的方式原始方式获取表单封装到实体类对象12345678910//获取表单数据 HttpServletRequest requesr = ServletActionContext.getRequest(); String username = requesr.getParameter("username"); String password = requesr.getParameter("password"); String address = requesr.getParameter("address"); //封装到实体类中 User user = new User(); user.setUsername(username); user.setPassword(password); user.serAddress(address); 1、属性封装（1）直接把表单提交属性封装到action的属性里面（2）实现步骤 在action成员变量位置定义变量。变量名称和表单输入项的name属性值一样 生成变量的set和get方法 1234567891011121314151617181920212223242526public class Damo extends ActionSupport &#123; //定义变量，名称和 private String username; private String password; private String address; //生成set、get方法 public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 使用属性封装获取表单数据到属性里面，不能把数据直接封装到实体类对象里面2、模型驱动封装（1）使用模型驱动方式，可以直接把表单数据封装到实体类对象里面（2）实现步骤 action实现接口 ModelDriven. 1public class Damo extends ActionSupport implements ModelDriven&lt;User&gt; 实现接口里面的方法 getModel方法,把创建对象返回 在action里面创建实体类对象 1234567//创建对象 private User user = new User(); public User getModel() &#123; //返回创建user对象 return user; &#125; //表单输入项name属性值和实体类属性名称一样 （3）使用模型驱动和属性封装注意问题在一个action中，获取表单数据可以属性封装，使用模型驱动封装，不能同时使用属性封装和模型驱动封装获取同一个表单数据如果同时使用，只会执行模型驱动 3、表达式封装（1）实现过程 使用表达式封装可以把表单数据封装到实体类对象里面第一步 在action里面声明实体类第二步 生成实体类变量的set和get方法 123456789//声明实体类 private User user; //生成实体类的get、set方法 public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; 第三步 在表单输入项的name属性值里面写表达式形式 123456 用户名：&lt;input type="text" name="user.username"&gt;&lt;br&gt; 密 码：&lt;input type="text" name="user.password"&gt;&lt;br&gt; 地 址：&lt;input type="text" name="user.address"&gt;&lt;br&gt; （2）把表达式封装归类到属性封装里面4、表达式封装和模型驱动封装比较（1）相同点：表达式封装和模型驱动封装都可以把数据封装到实体类对象里面（2）不同点： 使用模型驱动只能把数据封装到一个实体类对象里面，在一个action里面不能使用模型驱动把数据封装到不同的实体类对象里面 使用表达式封装可以把数据封装到不同的实体类对象里面。（action中可以声明多个实体类） 四、struts2获取数据封装到集合中1、封装到list集合（1）在action声明List（2）生成list变量的set和get方法123456789//声明List变量 private List&lt;User&gt; list; //生成get和set方法 public List&lt;User&gt; getList() &#123; return list; &#125; public void setList(List&lt;User&gt; list) &#123; this.list = list; &#125; （3）在表单输入项里面写表达式12345678910111213 用户名：&lt;input type="text" name="list[0].username"&gt;&lt;br&gt; 密 码：&lt;input type="text" name="list[0].password"&gt;&lt;br&gt; 地 址：&lt;input type="text" name="list[0].address"&gt;&lt;br&gt; 用户名：&lt;input type="text" name="list[1].username"&gt;&lt;br&gt; 密 码：&lt;input type="text" name="list[1].password"&gt;&lt;br&gt; 地 址：&lt;input type="text" name="list[1].address"&gt;&lt;br&gt; 2、 封装到map集合（1）action中声明map集合（2）生成get、set方法123456789//声明map集合 private Map&lt;String, User&gt; map; //生成set、get方法 public Map&lt;String, User&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, User&gt; map) &#123; this.map = map; &#125; （3）表单输入项的name属性值里面写表达式1234567891011&lt;!-- 设置key值 map['key值'] 设置value值 --&gt; username:&lt;input type="text" name="map['one'].username"/&gt; &lt;br/&gt; password:&lt;input type="text" name="map['one'].password"/&gt; &lt;br/&gt; address:&lt;input type="text" name="map['one'].address"/&gt; &lt;br/&gt;&lt;br/&gt; username:&lt;input type="text" name="map['two'].username"/&gt; &lt;br/&gt; password:&lt;input type="text" name="map['two'].password"/&gt; &lt;br/&gt;]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2_03]]></title>
    <url>%2F2019%2F04%2F20%2Fstruts2_03%2F</url>
    <content type="text"><![CDATA[struts2学习_03struts2核心配置文件 1、struts.xml名称和位置固定。默认放在项目的src源文件夹下，如果想改变位置，可以在web.xml中配置。 2、配置文件中主要三个标签有package、action、result，标签里的属性。标签package 1 类似于代码包，区别不同的action，要配置action，必须首先写package标签，在package里面才能 配置action 2 package标签属性（1）name属性。 name属性值根功能本身没有关系的，在一个配置文件中可以写多个package标签，name属性值不能相同的（2）extends属性。extends=&quot;struts-default&quot;属性值固定的，struts-default写了这个属性之后，在package里面配置的类具有action功能（3）namespace属性。namespace=&quot;/&quot;namespace属性值和action标签里面的name属性值构成访问路径标签action 1 action标签里配置action访问路径 2 action标签属性（1）name属性namespace属性值和action标签里面的name属性值构成访问路径在package标签里面写多个action标签，但是action的name属性值不能相同的（2）class属性action类的全路径（3）method属性比如在action里面默认执行的方法execute方法，但是在action里面写其他的方法，让action里面多个方法执行，使用method进行配置标签result 1 根据action的方法返回值，配置到不同的路径里面 2 result标签属性（1）name属性和action中的方法返回值相同，配置返回值跳转至不同的页面（2）type属性配置如何到路径中（转发或者重定向）type属性默认值 做转发操作（不写）struts2常量配置 1 struts2框架，帮我们实现一部分功能，struts2里有常量，在常量中封装一部分功能 2 struts2默认常量位置为，项目库struts2核心jar包下struts2-core-2.3.24.jar/org.apache.struts2/default.properties 3 修改struts2默认常量值 （1）常用方式在struts,xml中进行配置&lt;constant name=&quot;struts.i18n.encoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/constant&gt;（2）还有两种方式在src下面创建 struts.properties，进行修改在web.xml进行配置 4 最常用常量struts.i18n.encoding=UTF-8(1）表单提交数据到action里面，在action可以获取表单提交数据，(2）表单提交数据有中文，有乱码问题，解决：post提交直接设置编码get提交后需要做编码转换(3）如果在action获取表单通过post方式提交中文，中文乱码问题帮解决了，不需要自己处理问题分模块开发 单独写配置文件，把配置文件引入到核心配置文件中&lt;!-- 引入hello.xml文件 --&gt;&lt;include file=&quot;cn/com/action/hello.xml&quot;&gt;&lt;/include&gt; action编写方式 1 action编写有三种方式第一种 创建普通类，这个不继承任何类，不实现任何接口第二种 创建类，实现接口 Action第三种 创建类，继承类 ActionSupport（经常使用） 访问action的方法 1 有三种方式实现第一种 使用action标签的method属性，在这个属性里面写执行的action的方法第二种 使用通配符方式实现（最常用）第三种 动态方法调用 2 常犯错误（1）如果action方法有返回值，在配置文件中没有配置，出现404错误（2）在action里面的方法有返回值，如果有返回值时候类型必须是String（3）action里面的方法可以没有返回值，没有返回值时候，在result标签不需要配置或者 把方法写成void 让返回值，返回 ”none” 3 使用action标签method属性 &lt;action name=&quot;userAction&quot; class=&quot;cn.com.action.HelloAction&quot; method=&quot;add&quot;&gt;&lt;/action&gt;action标签的method属性值是action类中的方法名缺点：action每个方法都需要配置，如果action里面有多个方法，配置很多的action 4 使用通配符实现（最常用）在action标签里面name属性，name属性值里面写 符号 星号`&lt;action name=”hello_“ class=”cn.com.action.HelloAction” method=”{1}”&gt;` “ ” 表示匹配任意内容 ，method={1}表示第一个“ ”的值。 比如说访问add方法，method={1}表示把add值放到第一个“ * ”号，最后访问的就是 hello_add.action这种方法的好处就是当配置太多时，通过合理设计jsp中的结尾和类名及方法名，可以极大减少代码量！ 5 动态方法调用首先在struts.xml中开启动态方法访问&lt;!--开启动态方法模式 --&gt;&lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot;&gt;&lt;/constant&gt;访问路劲写为：&lt;a href=&quot;${pageContext.request.contextPath}/hello!addUser&quot;&gt;添加&lt;/a&gt;通过“！”前的字符找到action标签的name属性值，找到相应的类，“！”后面的字符表示执行的方法，类名和方法名找到了自然就可以调用方法]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2_02]]></title>
    <url>%2F2019%2F04%2F17%2Fstruts2_02%2F</url>
    <content type="text"><![CDATA[struts2学习_02struts2执行过程 浏览器向服务器发送请求。 比如：localhost:8080/struts2_test1/userAction.action，Tomcat接收到请求，Tomcatserver来选择处理这个请求的Web应用，然后由struts2_test1这个web项目处理请求。 Tomcat服务器读取struts2_test1项目下的web.xml文件。 在web.xml下找到配置的struts2过滤器，请求会经过过滤器，`&lt;url-pattern&gt;/*&lt;/url-pattern&gt;`表示过滤所有请求。过滤器会在服务器启动时创建。 struts过滤器实现的功能、 第一步：获取请求路劲，得到路径中的userAction值 第二步：到src目录下找到struts.xml文件，使用dom4j解析得到xml文件中的内容，把拿到userAction值到struts.xml，找到action标签，匹配name是否相同 第三步：匹配name相同，找到所在action标签的class属性值，得到action全路径，使用反射实现功能。 反射实现过程： （1）.得到class。class clazz = class.forName(&quot;action全路径&quot;) （2）.得到名称是execute的方法。Method method = clazz.getMethod(&quot;execute&quot;) （3）.方法执行。Object obj = method.Invoke() 第四步：得到action的返回值，回到struts.xml中找到action标签下的result标签，配置result标签的name属性值，值一样跳转至相应的页面]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2_01]]></title>
    <url>%2F2019%2F04%2F17%2Fstruts2_01%2F</url>
    <content type="text"><![CDATA[struts2学习_01一、struts2概述1、Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。2、Struts 2是Struts的下一代产品，是在 struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。其全新的Struts 2的体系结构与Struts 1的体系结构差别巨大。Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品。虽然从Struts 1到Struts 2有着太大的变化，但是相对于WebWork，Struts 2的变化很小。 二、struts2框架入门 struts2版本为struts-2.3.24 第一步：导入struts2框架jar包（1）从struts2官网下载完整包解压，在lib目录中有jar包，不能把这些jar包都导入项目中，其中很多jar包用不上 （2）到apps目录中，找到示例程序解压，然后找到示例程序下的lib目录，复制里面的jar包到自己新建的web项目中 第二部：在web.xml中配置struts过滤器 123456789&lt;filter&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 第三步：创建action （1）新建一个普通类，然后在类中写execute方法 123456789101112public class HelloAction extends &#123; /** *(1)每次访问servlet时，都会执行service方法 *(2)每次访问action,默认执行execute方法 */ private static final long serialVersionUID = 1L; public String execute() &#123; return "ok"; &#125;&#125; 第四步：配置action的访问路径 （1）创建struts2核心配置文件， 核心配置文件名称和位置是固定的， 位置必须在src下面，名称 struts.xml （2）引入dtd约束 1234&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt; （3）struts.xml配置action访问路径 123456789&lt;struts&gt; &lt;!-- package标签的name属性值为包名，extends="struts-default"就是继承struts-default.xml，它里面定义了许多跳转类型、拦截器等一些常用的东西，namespace：命名空间，默认为'/'表示webapp根目录 --&gt; &lt;package name="hello" extends="struts-default" namespace="/"&gt; &lt;!-- action标签的name属性值为访问名称--&gt; &lt;action name="userAction" class="cn.com.action.HelloAction"&gt; &lt;result name="ok"&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 然后把项目部署到Tomcat中，在浏览器中访问，访问路劲为localhost:8080/struts2_test1/userAction.action，localhost:8080表示本机8080端口，也就是Tomcat 服务器端口，后面接上项目名和action名，用“/”隔开]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>struts2</tag>
      </tags>
  </entry>
</search>
