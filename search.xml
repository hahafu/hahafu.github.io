<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[struts2_06]]></title>
    <url>%2F2019%2F05%2F11%2Fstruts2_06%2F</url>
    <content type="text"><![CDATA[struts2学习_061、拦截器概述 Struts2框架中提供的许多功能都是使用拦截器实现的，包括异常处理，文件上传，生命周期回调和验证等。事实上，由于Struts2将其大部分功能基于拦截器，因此不太可能为每个action分配7个或8个拦截器。 拦截器在概念上与servlet过滤器或JDK代理类相同。拦截器允许横切功能，把action以及框架分开实现。你可以使用拦截器实现以下操作：在调用action之前提供预处理逻辑。在调用action后提供后处理逻辑。捕获异常，以便可以执行备用处理。 拦截器在action对象创建之后，action的方法执行之前执行 默认执行的拦截器 1234567891011121314151617181920212223242526&lt;interceptor-stack name="defaultStack"&gt; &lt;interceptor-ref name="exception"/&gt; &lt;interceptor-ref name="alias"/&gt; &lt;interceptor-ref name="servletConfig"/&gt; &lt;interceptor-ref name="i18n"/&gt; &lt;interceptor-ref name="prepare"/&gt; &lt;interceptor-ref name="chain"/&gt; &lt;interceptor-ref name="scopedModelDriven"/&gt; &lt;interceptor-ref name="modelDriven"/&gt; &lt;interceptor-ref name="fileUpload"/&gt; &lt;interceptor-ref name="checkbox"/&gt; &lt;interceptor-ref name="datetime"/&gt; &lt;interceptor-ref name="multiselect"/&gt; &lt;interceptor-ref name="staticParams"/&gt; &lt;interceptor-ref name="actionMappingParams"/&gt; &lt;interceptor-ref name="params"/&gt; &lt;interceptor-ref name="conversionError"/&gt; &lt;interceptor-ref name="validation"&gt; &lt;param name="excludeMethods"&gt;input,back,cancel,browse&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="workflow"&gt; &lt;param name="excludeMethods"&gt;input,back,cancel,browse&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="debugging"/&gt; &lt;interceptor-ref name="deprecation"/&gt; &lt;/interceptor-stack&gt; 2、拦截器底层原理拦截器底层使用两个原理aop思想和责任链模式 1 aop思想Aop是面向切面编程，是一种编程思想，没有具体的实现代码，简单来说就是不通过修改源代码方式扩展功能 2 责任链模式 在java中有很多的设计模式，责任链模式是其中的一种 责任链模式和过滤链很相似的 责任链模式：要执行多个操作，有添加、修改、删除三个操作。首先执行添加操作，添加操作执行之后 做类似于放行操作，再执行修改操作，修改操作执行之后做类似于放行操作，再执行删除操作 过滤链：一个请求可有多个过滤器进行过滤，只有通过当前过滤器才能到达下一个过滤器3 aop思想和责任链模式如何应用到拦截器里面 拦截器在action对象创建之后，action的方法执行之前执行 在action方法执行之前执行默认拦截器，执行过程使用aop思想，在action没有直接调用拦截器的方法，使用配置文件方式进行操作 在执行拦截器时候，执行很多的拦截器，这个过程使用责任链模式。只有通过当前过滤器才能到达下一个过滤器，通过了所有的过滤器才会执行方法 过程： 执行actionexecute.executeAction(request, response, mapping); 创建action对象，使用动态代理方式` ActionProxy proxy = getContainer().getInstance(ActionProxyFactory.class).createActionProxy(namespace, name, method, extraContext, true, false);` 执行action的方法proxy.execute(); 执行很多的拦截器，遍历执行if ( interceptors .hasNext()) { 执行类似放行操作的方法return invocation.invoke(); 3、过滤器和拦截器区别 拦截器是基于java的反射机制的，而过滤器是基于函数回调 拦截器不依赖于servlet容器，过滤器依赖于servlet容器 拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求起作用(包括action、servlet、jsp、html等等) 拦截器可以访问action上下文、值栈里的对象，而过滤器不能访问 在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时初始化一次。 4、Servlet和action区别 servlet默认第一次访问时候创建，创建一次，单实例对象 action每次访问时候创建，创建多次，多实例对象 5、自定义拦截器 在struts2里面有很多的拦截器，这些拦截器是struts2封装的功能，但是在实际开发中，struts2里面的拦截器中可以没有要使用的功能，这个时候需要自己写拦截器实现功能 拦截器结构(1)查看源代码拦截器结构继承AbstractInterceptor类class ModelDrivenInterceptor extends AbstractInterceptor打开AbstractInterceptor类class AbstractInterceptor implements Interceptor有三个方法：void init()初始化方法void destroy()销毁方法String intercept(ActionInvocation invocation) throws Exception拦截逻辑操作(2)开发中，建议使用另外一种方式写类，继承 MethodFilterInterceptor类实现让action里面某个的方法不进行拦截(3)让拦截器和action产生关联不是在action调用拦截器的方法，而是通过配置文件方式让建立关系 6、自定义登陆拦截器 需求：在项目中，有很多的action的超链接，需要实现只有在登录的状态下，才可以点击action的超链接实现功能，如果不是登录状态，点击action超链接则返回到登录页面 登录的状态：使用session域对象实现（1）登录成功之后，把数据放到session里面（2）判断session是否有值，可以知道是否是登录状态 实现登录的基本功能 12345678910111213141516public String login() &#123; //得到request对象 HttpServletRequest request = ServletActionContext.getRequest(); String userName = request.getParameter("userName"); String passWord = request.getParameter("passWord"); //判断用户名和密码是否正确（示例，没有连接数据库操作） if(userName.equals("admin") &amp;&amp; passWord.equals("123456")) &#123; //验证成功向session放值 request.getSession().setAttribute("userName", userName); return "loginSuccess"; &#125;else &#123; //失败，回到登陆页面 return "loginUI"; &#125; &#125; 添加登录拦截器功能（1）判断是否登录：判断session里面是否有名称是username的值（2）拦截器实现过程第一步 创建类，继承MethodFilterInterceptor类第二步 重写MethodFilterInterceptor类里面的方法写拦截器逻辑 12345678910111213141516171819202122public class Loginintercept extends MethodFilterInterceptor &#123; //在这个方法里写拦截器逻辑 @Override protected String doIntercept(ActionInvocation invocation) throws Exception &#123; //判断session中是否有userName值 //得到session HttpServletRequest request = ServletActionContext.getRequest(); Object object = request.getSession().getAttribute("userName"); //判断 if(object != null) &#123; //session中有值，登录状态 //告诉struts2可以继续执行下面的方法 return invocation.invoke(); &#125;else &#123; //session中没有值，未登录 //不继续执行下面的action，返回登录页面 //到struts.xml中result标签中，把返回值配置到登录页面或其他提示页面 return "loginUI"; &#125; &#125;&#125; 第三步 配置action和拦截器关系（注册拦截器）（1）在要拦截的action标签所在的package标签里声明拦截器 1234&lt;!-- 声明拦截器 --&gt;&lt;interceptors&gt; &lt;interceptor name="loginIntercept" class="cn.com.action.Loginintercept"&gt;&lt;/interceptor&gt;&lt;/interceptors （2）在具体的action中使用声明的拦截器 12&lt;!-- 使用自定义拦截器 --&gt;&lt;interceptor-ref name="loginIntercept"&gt;&lt;/interceptor-ref&gt; （3）struts2里面执行很多的默认拦截器，但是如果在action里面配置自定义拦截器默认拦截器就不会执行需要手动启用默认拦截器 12&lt;!-- 手动启用默认拦截器 --&gt;&lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt; 配置拦截器，对action里面方法进行拦截（1）在action里面有login的登录的方法，这个方法不需要拦截，如果这个方法都拦截，问题是，永远登录不进去了（拦截器默认拦截action中所有方法）（2）让login方法不进行拦截 1234567&lt;!-- 使用自定义拦截器 --&gt;&lt;interceptor-ref name="loginIntercept"&gt; &lt;!-- 配置action中某些方法不进行拦截 --&gt; &lt;!-- neme属性：excludeMethods --&gt; &lt;!-- 值为不进行拦截的方法名 --&gt; &lt;param name="excludeMethods"&gt;login&lt;/param&gt; &lt;/interceptor-ref&gt; 注：如果出现嵌套的页面，在提交表单的form标签中加上target=&quot;_parent&quot;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2_05]]></title>
    <url>%2F2019%2F05%2F08%2Fstruts2_05%2F</url>
    <content type="text"><![CDATA[struts2学习_05一、ognl概述 OGNL是Object-Graph Navigation Language的缩写，它是一种功能强大的表达式语言，通过它简单一致的表达式语法，可以存取对象的任意属性，调用对象的方法，遍历整个对象的结构图，实现字段类型转化等功能。它使用相同的表达式去存取对象的属性。 EL表达式在jsp页面获取域对象的值 OGNL是一种表达式，这个表达式功能更加强大在struts2里面操作值栈数据一般把ognl在struts2操作：和struts2标签一起使用操作值栈 OGNL不是struts2的一部分，单独的开源项目，struts2默认表达式为OGNL，经常和struts2一起使用。 使用时需要导入ognl的jar包，struts2提供jar包二、ognl入门案例1 使用ognl+struts2标签实现计算字符串长度 支持对象方法调用 在Java代码中，查看字符串长度用`.length()2 使用struts2标签（1）使用jstl时，导入jar包之外，还要在jsp页面引入标签库。使用struts2标签的时候，在jsp中引入标签库 1&lt;%@ taglib uri="/struts-tags" prefix="s" %&gt; （2）使用struts实现操作 12&lt;!-- 使用ognl和struts2标签实现计算字符串长度 value属性值：ognl表达式 --&gt;&lt;s:property value="'hello'.length()"/&gt; 三、值栈1、web阶段，在servlet里面进行操作，把数据放到域对象里面，在页面中使用el表达式获取到。域对象表示在一定范围内，存值和取值。2、在struts2里面提供本身一种存储机制，类似于域对象，是值栈，可以存值和取值 在action里面把数据放到值栈里面，在页面中获取到值栈数据 3、servlet和action的区别 Servlet：默认在第一次访问的时候创建，只创建一次，单实例对象 Action:访问时创建，每次访问action都会创建对象，创建多次，多实例对象 4、值栈存储位置 每次访问action时，都会创建action对象 在每个action对象里只有一个值栈对象 四、如何获取值栈对象获取值栈对象的多种方式1、常用方式：使用ActionContext类里的方法得到值栈对象1234//获取ActionContext类的对象 ActionContext context =ActionContext.getContext(); //调用方法得到值栈对象 ValueStack stack = context.getValueStack(); 2、使用 Request 对象获取值栈对象1234//通过 ServletActionContext 类的静态方法获取 Request 对象HttpServletRequest request = ServletActionContext.getRequest();//调用 Request 对象的方法，并传入 ServletActionContext 类的静态常量，获取值栈对象ValueStack stack = (ValueStack) request.getAttribute(ServletActionContext.STRUTS_VALUESTACK_KEY); 五、值栈的内部结构值栈包含两大部分，CompoundRoot和context1、第一部分，CompoundRoot，结构时list集合2、第二部分，context，常称为contextMap，结构是map集合 context存储对象引用 key(固定) value request request对象引用 session session对象引用 application application对象引用 parameters 传递相关参数 attr attr：Attribute,向三个域对象防值，名称都相同setAttribute(“name”,value); 使用attr操作，获取域对象里面的值，获取域范围最小的值 3、struts2里面标签 s:debug，使用这个标签可以查看值栈结构和存储值 访问action，执行action的方法有返回值，配置返回值到jsp页面中，在jsp页面中使用这个s:debug标签在页面点击超链接看到结构 在action没有做任何操作，栈顶元素是 action引用action对象里面有值栈对象值栈对象里面有action引用六、向值栈放入数据1 向值栈放数据1.1、第一种 获取值栈对象，调用值栈对象的set方法 123456//第一种方式：使用值栈对象的set方法//获取值栈对象ActionContext context = ActionContext.getContext();ValueStack stack = context.getValueStack();//调用set方法stack.set("username", "value"); 1.2、第二种 获取值栈对象，调用值栈对象的push方法12345678//获取值栈对象ActionContext context = ActionContext.getContext();ValueStack stack = context.getValueStack();//调用set方法stack.set("username", "value"); //调用push方法 stack.push("value"); 1.3、第三种 在action中定义变量，生成变量的get方法2、向值栈放对象 第一步 定义对象变量 第二部 生成变量的get方法 在执行的方法里向对象设置值 12345678910111213//1、定义对象变量private User user = new User();//生成get方法public User getUser() &#123; return user;&#125;@Overridepublic String execute() throws Exception &#123; //向值栈的user里放数据 user.setUsername("hello"); user.setPassword("123456"); return "success";&#125; 3、向值栈里放list集合 第一步 定义list集合变量 第二步 生成变量的get方法 执行的方法里面向list集合设置值 123456789101112131415//定义list变量 private List&lt;User&gt; list = new ArrayList&lt;User&gt;(); //生成get方法 public List&lt;User&gt; getList() &#123; return list; &#125; @Override public String execute() throws Exception &#123; //向list中设置值 User user = new User(); user.setUsername("hello"); user.setPassword("123456"); list.add(user); return "success"; &#125; 七、从值栈获取数据使用struts2的标签+ognl表达式获取值栈数据&lt;s:property value=”ognl表达式”/&gt; 1、获取字符串 向值栈放字符串 123456789private String userName;public String getUserName() &#123; return userName;&#125;@Overridepublic String execute() throws Exception &#123; userName = "hello"; return "success";&#125; 在jsp使用struts2标签+ognl表达式获取 12&lt;!-- 获取字符串 --&gt;&lt;s:property value="userName"/&gt; 2、获取对象 向值栈放对象 123456789101112private User user = new User(); //生成get方法 public User getUser() &#123; return user; &#125; @Override public String execute() throws Exception &#123; //向值栈的user里放数据 user.setUserName("hello"); user.setPassWord("123456"); return "success"; &#125; 在jsp页面中取值 12&lt;s:property value="user.userName"/&gt;&lt;s:property value="user.passWord"/&gt; 3、获取list集合在值栈中放入list集合1234567891011121314private List&lt;User&gt; list = new ArrayList&lt;User&gt;(); //生成get方法 public List&lt;User&gt; getList() &#123; return list; &#125; @Override public String execute() throws Exception &#123; //向list中设置值 User user = new User(); user.setUserName("hello"); user.setPassWord("123456"); list.add(user); return "success"; &#125; 3.1第一种方式实现获取list集合123&lt;!-- 第一种方式 --&gt;&lt;s:property value="list[0].userName"/&gt;&lt;s:property value="list[0].passWord"/&gt; 3.2 第二种方式实现获取list集合123456&lt;!-- 第二种方式 --&gt;&lt;!-- 遍历list集合得到list集合里每个user对象 --&gt;&lt;s:iterator value="list"&gt; &lt;s:property value="userName"/&gt; &lt;s:property value="passWord"/&gt;&lt;/s:iterator&gt; 3.3 第三种方式实现获取list集合123456789&lt;!-- 第三种方式 --&gt;&lt;!-- 遍历list集合得到list集合里每个user对象 --&gt;&lt;!-- 机制：把每次遍历出来的user对象放大context里 获取context数据的特点：写ognl表达式，需使用特殊符号# --&gt;&lt;s:iterator value="list" var="user"&gt; &lt;s:property value="#user.userName"/&gt; &lt;s:property value="#user.passWord"/&gt;&lt;/s:iterator&gt; 4、其他方式向值栈存放、获取数据4.1 使用set方法12//调用set方法设置值stack.set("username", "value"); 12&lt;!-- 获取set方法设置的值，根据名称获取 --&gt;&lt;s:property value="username"/&gt; 4.2 使用push方法 使用push方法设置值，没有名称，只有设置的值 push方法只接收一个Object类型的参数，可以存放任意类型的对象 push方法是自动将所存的数据转为对应的对象类型，然后存到值栈 top 数组中 12&lt;!-- 获取push方法设置的值,通过top数组 --&gt;&lt;s:property value="[0].top"/&gt; 八、EL表达式获取值栈数据 EL表达式获取域对象值 为什么El表达式可以获取值栈的数据？ struts2过滤器增强request对象里面的方法getAttribute方法。在过核心过滤器的时候，对request进行了加强，对request中的getAttribute查找属性方法进行了加强。如果在request域中找不到数据，会默认到值栈中去查找，把值栈的数据取出来，放到域对象里。 九、ognl表达式#、%的使用1、#使用12345678&lt;!-- 遍历list集合得到list集合里每个user对象 --&gt;&lt;!-- 机制：把每次遍历出来的user对象放大context里 获取context数据的特点：写ognl表达式，需使用特殊符号# --&gt;&lt;s:iterator value="list" var="user"&gt; &lt;s:property value="#user.userName"/&gt; &lt;s:property value="#user.passWord"/&gt;&lt;/s:iterator&gt; 123&lt;!-- 获取context中request的值 --&gt;&lt;!-- #context的key名.域对象名称 （key如request） --&gt;&lt;s:property value="#request.hello"/&gt; 2、%使用 在struts2标签中表单标签 在struts2标签里面使用ognl表达式，如果直接在struts2表单标签里面使用ognl表达式不识别，只有%之后才会识别 1&lt;s:textfield name="userName" value="%&#123;#request.hello&#125;"&gt;&lt;/s:textfield&gt;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2_04]]></title>
    <url>%2F2019%2F04%2F24%2Fstruts2_04%2F</url>
    <content type="text"><![CDATA[struts2学习_04一、结果页面配置1、全局结果页面（1）result标签配置action方法返回值到不同的路劲里面（2）创建两个Action执行默认的方法execute方法，让两个方法都返回success,返回success之后，配置到同一个页面 如果多个action，方法里面返回值相同的，到页面也是相同的这个时候可以使用全局结果页面配置 12345678&lt;package name="Stationery" extends="struts-default" namespace="/"&gt; &lt;action name="book" class="cn.com.action.BookAction"&gt; &lt;result name="success"&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="pen" class="cn.com.action.PenAction"&gt; &lt;result name="success"&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 在package标签里配置全局结果页面 1234&lt;!-- 全局结果页面配置 --&gt; &lt;global-results&gt; &lt;result name="success"&gt;/hello.jsp&lt;/result&gt; &lt;/global-results&gt; 2、局部结果页面配置了全局结果页面，也配置了局部结果页面，最终以局部结果页面配置为准1234567891011121314&lt;package name="Stationery" extends="struts-default" namespace="/"&gt; &lt;!-- 全局结果页面配置 --&gt; &lt;global-results&gt; &lt;result name="success"&gt;/hello.jsp&lt;/result&gt; &lt;/global-results&gt; &lt;!-- 局部结果页面配置 --&gt; &lt;action name="book" class="cn.com.action.BookAction"&gt; &lt;!-- 以局部结果页面配置为准 --&gt; &lt;result name="success"&gt;/book.jsp&lt;/result&gt; &lt;/action&gt; &lt;action name="pen" class="cn.com.action.PenAction"&gt; &lt;result name="success"&gt;/pen.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt; 3、Result标签type属性（1）result标签除了有name属性，还有type属性 type属性：如何到路径里面（转发和重定向）（2）type属性值 dispatcher：默认值，请求转发操作， dispatcher：重定向操作，无法共享请求范围内的数据 chain：将action的带着原来的状态请求转发到新的action，一般不建议使用，缓存问题 redirect-action：重定向到另一个Action，参数与chain用法相同，允许将原Action中的属性指定新名称带入新Action中 dispatcher、redirect，这两个值一般针对到页面中配置 chain、redirect-action配置到其他action里 二、在action获取表单提交数据1 之前web阶段，提交表单到servlet里面，在servlet里面使用request对象里面的方法获取，getParameter，getParameterMap 2 提交表单到action，但是action没有request对象，不能直接使用request对象 3 action获取表单提交数据主要三种方式（1）使用ActionContext类（2）使用ServletActionContext类（3）使用接口注入方式 1、使用ActionContext类获取（1）使用方法 Map&lt;String,Object&gt;getParameter() 返回一个含有HttpServletRequest参数信 static ActionContext getContext() 获取当前线程的ActionContext对像 方法不是静态的，需要创建ActionContext类对象 ActionContext对象不是new出来的（2）具体实现 创建表单，提交表单到action 在action的方法中使用ActionContext获取数据123456789101112//使用ActionContext类获取表单数据 //1、获取actionContext对象 ActionContext context = ActionContext.getContext(); //2、调用方法得到表单数据 //key是表单输入项里的name值，value是输入的值 Map&lt;String, Object&gt; map = context.getParameters(); Set&lt;String&gt; keys=map.keySet(); for (String key : keys) &#123; //用数组形式是因为输入项可能有复选框的情况 Object[] obj = (Object[]) map.get(key); System.out.println(Arrays.toString(obj)); &#125; 2、使用servletActionContext类获取 static HttpServletRequest() 获取Web应用的 HttpServletRequest对象 static HttpServletResponse() 获取Web应用的 HttpServletResponse对象 static ServletContext.getServletContext 获取Web应用的 ServletContext对象 static PageContext.getPageContext 获取Web应用的 PageContext对象 （1）使用方法 调用类的静态方法，得到request对象 action中代码实现 1234567891011public String execute() throws Exception &#123; //使用ServletActionContext获取request对象 HttpServletRequest request = ServletActionContext.getRequest(); //调用request里的方法得到结果 String userName = request.getParameter("userName"); String password = request.getParameter("password"); String address = request.getParameter("address"); return NONE;&#125; 3、使用接口注入方式获取（1）让action类实现ServletRequestAware接口12345678910111213public class HelloAction extends ActionSupport implements ServletRequestAware&#123; private HttpServletRequest request; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request = request; &#125; @Override public String execute() throws Exception &#123; request.getParameter(""); return super.execute(); &#125; &#125; 4、在action操作域对象（1）request、session、servletContext域对象（2）使用ServletActionContext类操作123456789//request域 HttpServletRequest request = ServletActionContext.getRequest(); request.setAttribute("requestName", "requestValue"); //session域 HttpSession session = request.getSession(); session.setAttribute("sessionName", "sessionValue"); //servletContext域 ServletContext context = ServletActionContext.getServletContext(); context.setAttribute("contextName", "contextValue"); 三、struts2提供获取表单数据的方式原始方式获取表单封装到实体类对象12345678910//获取表单数据 HttpServletRequest requesr = ServletActionContext.getRequest(); String username = requesr.getParameter("username"); String password = requesr.getParameter("password"); String address = requesr.getParameter("address"); //封装到实体类中 User user = new User(); user.setUsername(username); user.setPassword(password); user.serAddress(address); 1、属性封装（1）直接把表单提交属性封装到action的属性里面（2）实现步骤 在action成员变量位置定义变量。变量名称和表单输入项的name属性值一样 生成变量的set和get方法 1234567891011121314151617181920212223242526public class Damo extends ActionSupport &#123; //定义变量，名称和 private String username; private String password; private String address; //生成set、get方法 public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125;&#125; 使用属性封装获取表单数据到属性里面，不能把数据直接封装到实体类对象里面2、模型驱动封装（1）使用模型驱动方式，可以直接把表单数据封装到实体类对象里面（2）实现步骤 action实现接口 ModelDriven. 1public class Damo extends ActionSupport implements ModelDriven&lt;User&gt; 实现接口里面的方法 getModel方法,把创建对象返回 在action里面创建实体类对象 1234567//创建对象 private User user = new User(); public User getModel() &#123; //返回创建user对象 return user; &#125; //表单输入项name属性值和实体类属性名称一样 （3）使用模型驱动和属性封装注意问题在一个action中，获取表单数据可以属性封装，使用模型驱动封装，不能同时使用属性封装和模型驱动封装获取同一个表单数据如果同时使用，只会执行模型驱动 3、表达式封装（1）实现过程 使用表达式封装可以把表单数据封装到实体类对象里面第一步 在action里面声明实体类第二步 生成实体类变量的set和get方法 123456789//声明实体类 private User user; //生成实体类的get、set方法 public User getUser() &#123; return user; &#125; public void setUser(User user) &#123; this.user = user; &#125; 第三步 在表单输入项的name属性值里面写表达式形式 123456 用户名：&lt;input type="text" name="user.username"&gt;&lt;br&gt; 密 码：&lt;input type="text" name="user.password"&gt;&lt;br&gt; 地 址：&lt;input type="text" name="user.address"&gt;&lt;br&gt; （2）把表达式封装归类到属性封装里面4、表达式封装和模型驱动封装比较（1）相同点：表达式封装和模型驱动封装都可以把数据封装到实体类对象里面（2）不同点： 使用模型驱动只能把数据封装到一个实体类对象里面，在一个action里面不能使用模型驱动把数据封装到不同的实体类对象里面 使用表达式封装可以把数据封装到不同的实体类对象里面。（action中可以声明多个实体类） 四、struts2获取数据封装到集合中1、封装到list集合（1）在action声明List（2）生成list变量的set和get方法123456789//声明List变量 private List&lt;User&gt; list; //生成get和set方法 public List&lt;User&gt; getList() &#123; return list; &#125; public void setList(List&lt;User&gt; list) &#123; this.list = list; &#125; （3）在表单输入项里面写表达式12345678910111213 用户名：&lt;input type="text" name="list[0].username"&gt;&lt;br&gt; 密 码：&lt;input type="text" name="list[0].password"&gt;&lt;br&gt; 地 址：&lt;input type="text" name="list[0].address"&gt;&lt;br&gt; 用户名：&lt;input type="text" name="list[1].username"&gt;&lt;br&gt; 密 码：&lt;input type="text" name="list[1].password"&gt;&lt;br&gt; 地 址：&lt;input type="text" name="list[1].address"&gt;&lt;br&gt; 2、 封装到map集合（1）action中声明map集合（2）生成get、set方法123456789//声明map集合 private Map&lt;String, User&gt; map; //生成set、get方法 public Map&lt;String, User&gt; getMap() &#123; return map; &#125; public void setMap(Map&lt;String, User&gt; map) &#123; this.map = map; &#125; （3）表单输入项的name属性值里面写表达式1234567891011&lt;!-- 设置key值 map['key值'] 设置value值 --&gt; username:&lt;input type="text" name="map['one'].username"/&gt; &lt;br/&gt; password:&lt;input type="text" name="map['one'].password"/&gt; &lt;br/&gt; address:&lt;input type="text" name="map['one'].address"/&gt; &lt;br/&gt;&lt;br/&gt; username:&lt;input type="text" name="map['two'].username"/&gt; &lt;br/&gt; password:&lt;input type="text" name="map['two'].password"/&gt; &lt;br/&gt;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2_03]]></title>
    <url>%2F2019%2F04%2F20%2Fstruts2_03%2F</url>
    <content type="text"><![CDATA[struts2学习_03struts2核心配置文件 1、struts.xml名称和位置固定。默认放在项目的src源文件夹下，如果想改变位置，可以在web.xml中配置。 2、配置文件中主要三个标签有package、action、result，标签里的属性。标签package 1 类似于代码包，区别不同的action，要配置action，必须首先写package标签，在package里面才能 配置action 2 package标签属性（1）name属性。 name属性值根功能本身没有关系的，在一个配置文件中可以写多个package标签，name属性值不能相同的（2）extends属性。extends=&quot;struts-default&quot;属性值固定的，struts-default写了这个属性之后，在package里面配置的类具有action功能（3）namespace属性。namespace=&quot;/&quot;namespace属性值和action标签里面的name属性值构成访问路径标签action 1 action标签里配置action访问路径 2 action标签属性（1）name属性namespace属性值和action标签里面的name属性值构成访问路径在package标签里面写多个action标签，但是action的name属性值不能相同的（2）class属性action类的全路径（3）method属性比如在action里面默认执行的方法execute方法，但是在action里面写其他的方法，让action里面多个方法执行，使用method进行配置标签result 1 根据action的方法返回值，配置到不同的路径里面 2 result标签属性（1）name属性和action中的方法返回值相同，配置返回值跳转至不同的页面（2）type属性配置如何到路径中（转发或者重定向）type属性默认值 做转发操作（不写）struts2常量配置 1 struts2框架，帮我们实现一部分功能，struts2里有常量，在常量中封装一部分功能 2 struts2默认常量位置为，项目库struts2核心jar包下struts2-core-2.3.24.jar/org.apache.struts2/default.properties 3 修改struts2默认常量值 （1）常用方式在struts,xml中进行配置&lt;constant name=&quot;struts.i18n.encoding&quot; value=&quot;UTF-8&quot;&gt;&lt;/constant&gt;（2）还有两种方式在src下面创建 struts.properties，进行修改在web.xml进行配置 4 最常用常量struts.i18n.encoding=UTF-8(1）表单提交数据到action里面，在action可以获取表单提交数据，(2）表单提交数据有中文，有乱码问题，解决：post提交直接设置编码get提交后需要做编码转换(3）如果在action获取表单通过post方式提交中文，中文乱码问题帮解决了，不需要自己处理问题分模块开发 单独写配置文件，把配置文件引入到核心配置文件中&lt;!-- 引入hello.xml文件 --&gt;&lt;include file=&quot;cn/com/action/hello.xml&quot;&gt;&lt;/include&gt; action编写方式 1 action编写有三种方式第一种 创建普通类，这个不继承任何类，不实现任何接口第二种 创建类，实现接口 Action第三种 创建类，继承类 ActionSupport（经常使用） 访问action的方法 1 有三种方式实现第一种 使用action标签的method属性，在这个属性里面写执行的action的方法第二种 使用通配符方式实现（最常用）第三种 动态方法调用 2 常犯错误（1）如果action方法有返回值，在配置文件中没有配置，出现404错误（2）在action里面的方法有返回值，如果有返回值时候类型必须是String（3）action里面的方法可以没有返回值，没有返回值时候，在result标签不需要配置或者 把方法写成void 让返回值，返回 ”none” 3 使用action标签method属性 &lt;action name=&quot;userAction&quot; class=&quot;cn.com.action.HelloAction&quot; method=&quot;add&quot;&gt;&lt;/action&gt;action标签的method属性值是action类中的方法名缺点：action每个方法都需要配置，如果action里面有多个方法，配置很多的action 4 使用通配符实现（最常用）在action标签里面name属性，name属性值里面写 符号 星号`&lt;action name=”hello_“ class=”cn.com.action.HelloAction” method=”{1}”&gt;` “ ” 表示匹配任意内容 ，method={1}表示第一个“ ”的值。 比如说访问add方法，method={1}表示把add值放到第一个“ * ”号，最后访问的就是 hello_add.action这种方法的好处就是当配置太多时，通过合理设计jsp中的结尾和类名及方法名，可以极大减少代码量！ 5 动态方法调用首先在struts.xml中开启动态方法访问&lt;!--开启动态方法模式 --&gt;&lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;true&quot;&gt;&lt;/constant&gt;访问路劲写为：&lt;a href=&quot;${pageContext.request.contextPath}/hello!addUser&quot;&gt;添加&lt;/a&gt;通过“！”前的字符找到action标签的name属性值，找到相应的类，“！”后面的字符表示执行的方法，类名和方法名找到了自然就可以调用方法]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2_02]]></title>
    <url>%2F2019%2F04%2F17%2Fstruts2_02%2F</url>
    <content type="text"><![CDATA[struts2学习_02struts2执行过程 浏览器向服务器发送请求。 比如：localhost:8080/struts2_test1/userAction.action，Tomcat接收到请求，Tomcatserver来选择处理这个请求的Web应用，然后由struts2_test1这个web项目处理请求。 Tomcat服务器读取struts2_test1项目下的web.xml文件。 在web.xml下找到配置的struts2过滤器，请求会经过过滤器，`&lt;url-pattern&gt;/*&lt;/url-pattern&gt;`表示过滤所有请求。过滤器会在服务器启动时创建。 struts过滤器实现的功能、 第一步：获取请求路劲，得到路径中的userAction值 第二步：到src目录下找到struts.xml文件，使用dom4j解析得到xml文件中的内容，把拿到userAction值到struts.xml，找到action标签，匹配name是否相同 第三步：匹配name相同，找到所在action标签的class属性值，得到action全路径，使用反射实现功能。 反射实现过程： （1）.得到class。class clazz = class.forName(&quot;action全路径&quot;) （2）.得到名称是execute的方法。Method method = clazz.getMethod(&quot;execute&quot;) （3）.方法执行。Object obj = method.Invoke() 第四步：得到action的返回值，回到struts.xml中找到action标签下的result标签，配置result标签的name属性值，值一样跳转至相应的页面]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[struts2_01]]></title>
    <url>%2F2019%2F04%2F17%2Fstruts2_01%2F</url>
    <content type="text"><![CDATA[struts2学习_01一、struts2概述1、Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互。2、Struts 2是Struts的下一代产品，是在 struts 1和WebWork的技术基础上进行了合并的全新的Struts 2框架。其全新的Struts 2的体系结构与Struts 1的体系结构差别巨大。Struts 2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts 2可以理解为WebWork的更新产品。虽然从Struts 1到Struts 2有着太大的变化，但是相对于WebWork，Struts 2的变化很小。 二、struts2框架入门 struts2版本为struts-2.3.24 第一步：导入struts2框架jar包（1）从struts2官网下载完整包解压，在lib目录中有jar包，不能把这些jar包都导入项目中，其中很多jar包用不上 （2）到apps目录中，找到示例程序解压，然后找到示例程序下的lib目录，复制里面的jar包到自己新建的web项目中 第二部：在web.xml中配置struts过滤器 123456789&lt;filter&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 第三步：创建action （1）新建一个普通类，然后在类中写execute方法 123456789101112public class HelloAction extends &#123; /** *(1)每次访问servlet时，都会执行service方法 *(2)每次访问action,默认执行execute方法 */ private static final long serialVersionUID = 1L; public String execute() &#123; return "ok"; &#125;&#125; 第四步：配置action的访问路径 （1）创建struts2核心配置文件， 核心配置文件名称和位置是固定的， 位置必须在src下面，名称 struts.xml （2）引入dtd约束 1234&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt; （3）struts.xml配置action访问路径 123456789&lt;struts&gt; &lt;!-- package标签的name属性值为包名，extends="struts-default"就是继承struts-default.xml，它里面定义了许多跳转类型、拦截器等一些常用的东西，namespace：命名空间，默认为'/'表示webapp根目录 --&gt; &lt;package name="hello" extends="struts-default" namespace="/"&gt; &lt;!-- action标签的name属性值为访问名称--&gt; &lt;action name="userAction" class="cn.com.action.HelloAction"&gt; &lt;result name="ok"&gt;/hello.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 然后把项目部署到Tomcat中，在浏览器中访问，访问路劲为localhost:8080/struts2_test1/userAction.action，localhost:8080表示本机8080端口，也就是Tomcat 服务器端口，后面接上项目名和action名，用“/”隔开]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>struts2</tag>
      </tags>
  </entry>
</search>
